// lib/screens/main/my_list/sentence_list_screen.dart
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:image_picker/image_picker.dart';
import 'package:firebase_auth/firebase_auth.dart';

class SentenceListScreen extends StatefulWidget {
  const SentenceListScreen({super.key});
  @override
  State<SentenceListScreen> createState() => _SentenceListScreenState();
}

class _SentenceListScreenState extends State<SentenceListScreen> {
  final _selectedIds = <String>{};
  List<QueryDocumentSnapshot<Map<String, dynamic>>> _lastDocs = [];

  String? _uid;
  bool _authError = false;

  @override
  void initState() {
    super.initState();
    _ensureSignedIn();
  }

  Future<void> _ensureSignedIn() async {
    try {
      final auth = FirebaseAuth.instance;
      if (auth.currentUser == null) {
        await auth.signInAnonymously();
      }
      setState(() => _uid = FirebaseAuth.instance.currentUser!.uid);
    } catch (e) {
      setState(() => _authError = true);
    }
  }

  Stream<QuerySnapshot<Map<String, dynamic>>> _stream() {
    // UID Í∏∞Î∞òÏúºÎ°ú ÎÇ¥ Î¨∏Ïû•Îßå Ï°∞Ìöå (Î≥¥Ïïà Í∑úÏπôÍ≥º ÏùºÏπò)
    return FirebaseFirestore.instance
        .collection('sentences')
        .where('uid', isEqualTo: _uid)
        .orderBy('createdAt', descending: true) // ‚Üê Ïù∏Îç±Ïä§ ÎßåÎì§ÎùºÎäî ÏïàÎÇ¥Í∞Ä Îú∞ Ïàò ÏûàÏñ¥Ïöî
        .snapshots();
  }

  bool get _selectionMode => _selectedIds.isNotEmpty;

  @override
  Widget build(BuildContext context) {
    if (_authError) {
      return const Scaffold(
        body: Center(child: Text('Î°úÍ∑∏Ïù∏Ïóê Ïã§Ìå®ÌñàÏñ¥Ïöî. ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÉÅÌÉúÎ•º ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.')),
      );
    }
    if (_uid == null) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title:
        Text(_selectionMode ? 'Î¨∏Ïû• ÏÑ†ÌÉùÎê® ${_selectedIds.length}Í∞ú' : 'Î¨∏Ïû•Î¶¨Ïä§Ìä∏'),
        actions: [
          if (_selectionMode) ...[
            IconButton(
              tooltip: 'ÌîåÎûòÏãúÏπ¥Îìú ÏÑ∏Ìä∏ ÎßåÎì§Í∏∞',
              icon: const Icon(Icons.style),
              onPressed: _createFlashcardSetFromSelection,
            ),
            IconButton(
              tooltip: 'ÏÑ†ÌÉù Ìï¥Ï†ú',
              icon: const Icon(Icons.clear),
              onPressed: () => setState(_selectedIds.clear),
            ),
          ] else ...[
            IconButton(
              tooltip: 'Î¨∏Ïû• Ï∂îÍ∞Ä',
              icon: const Icon(Icons.add),
              onPressed: () => _openAddDialog(context),
            ),
          ],
        ],
      ),
      body: StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
        stream: _stream(),
        builder: (context, snap) {
          if (snap.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (snap.hasError) {
            debugPrint("üî• SentenceListScreen stream error: ${snap.error}");
            debugPrint("Stack trace: ${snap.stackTrace}");

            return Center(child: Text('Ïò§Î•ò: ${snap.error}'));
          }
          final docs = snap.data?.docs ?? [];
          _lastDocs = docs;
          if (docs.isEmpty) {
            return const _EmptyHint();
          }

          return ListView.separated(
            itemCount: docs.length,
            separatorBuilder: (_, __) => const Divider(height: 1),
            itemBuilder: (context, i) {
              final doc = docs[i];
              final d = doc.data();
              final sentence = (d['sentence'] ?? '') as String;
              final meaning = (d['meaning'] ?? '') as String;
              final imageUrl = (d['imageUrl'] ?? '') as String;
              final selected = _selectedIds.contains(doc.id);

              return ListTile(
                leading: imageUrl.isEmpty
                    ? const Icon(Icons.chat_bubble_outline)
                    : ClipRRect(
                  borderRadius: BorderRadius.circular(6),
                  child: Image.network(
                    imageUrl,
                    width: 48,
                    height: 48,
                    fit: BoxFit.cover,
                  ),
                ),
                title: Text(
                  sentence,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                subtitle: meaning.isEmpty
                    ? null
                    : Text(
                  meaning,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                trailing: _selectionMode
                    ? Checkbox(
                  value: selected,
                  onChanged: (_) => _toggleSelect(doc.id),
                )
                    : null,
                onLongPress: () => _toggleSelect(doc.id),
                onTap: () {
                  if (_selectionMode) {
                    _toggleSelect(doc.id);
                  } else {
                    // TODO: ÏÉÅÏÑ∏ Î≥¥Í∏∞/Ìé∏Ïßë
                  }
                },
              );
            },
          );
        },
      ),
    );
  }

  void _toggleSelect(String id) {
    setState(() {
      if (_selectedIds.contains(id)) {
        _selectedIds.remove(id);
      } else {
        _selectedIds.add(id);
      }
    });
  }

  Future<void> _openAddDialog(BuildContext context) async {
    final sentenceCtl = TextEditingController();
    final meaningCtl = TextEditingController();
    XFile? picked;

    await showDialog(
      context: context,
      builder: (_) => StatefulBuilder(builder: (context, setState) {
        Future<void> save() async {
          final sentence = sentenceCtl.text.trim();
          final meaning = meaningCtl.text.trim();
          if (sentence.isEmpty) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Î¨∏Ïû•ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.')),
            );
            return;
          }

          // Î°úÍ∑∏Ïù∏ Î≥¥Ïû• Î∞è uid ÌôïÎ≥¥
          await _ensureSignedIn();
          final uid = _uid!;
          final col = FirebaseFirestore.instance.collection('sentences');
          final docRef = col.doc();

          String imageUrl = '';
          try {
            if (picked != null) {
              final data = await picked!.readAsBytes();
              // ÏÇ¨Ïö©Ïûê Í≤ΩÎ°úÏóê Ï†ÄÏû• ‚Üí Storage Í∑úÏπôÍ≥º Îß§Ïπ≠
              final path = 'users/$uid/sentences/${docRef.id}.jpg';
              final task = await FirebaseStorage.instance
                  .ref(path)
                  .putData(data, SettableMetadata(contentType: 'image/jpeg'));
              imageUrl = await task.ref.getDownloadURL();
            }

            await docRef.set({
              'uid': uid, // Î¨∏ÏÑú ÏÜåÏú†Ïûê Í∏∞Î°ù(Î≥¥Ïïà Í∑úÏπô ÎåÄÏùë)
              'sentence': sentence,
              'meaning': meaning,
              'imageUrl': imageUrl,
              'createdAt': FieldValue.serverTimestamp(),
            });

            if (context.mounted) {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.')),
              );
            }
          } catch (e) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Ï†ÄÏû• Ïã§Ìå®: $e')),
            );
          }
        }

        return AlertDialog(
          title: const Text('Î¨∏Ïû• Ï∂îÍ∞Ä'),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: sentenceCtl,
                  autofocus: true,
                  decoration: const InputDecoration(
                    labelText: 'Î¨∏Ïû•',
                    hintText: 'Ïòà) I need a nap.',
                  ),
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: meaningCtl,
                  decoration: const InputDecoration(
                    labelText: 'Îúª (ÏÑ†ÌÉù)',
                    hintText: 'Ïòà) ÎÇò ÎÇÆÏû† ÌïÑÏöîÌï¥.',
                  ),
                ),
                const SizedBox(height: 12),
                Row(
                  children: [
                    ElevatedButton.icon(
                      onPressed: () async {
                        final x = await ImagePicker().pickImage(
                          source: ImageSource.gallery,
                          maxWidth: 2000,
                        );
                        if (x != null) setState(() => picked = x);
                      },
                      icon: const Icon(Icons.image),
                      label: const Text('Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù'),
                    ),
                    const SizedBox(width: 12),
                    if (picked != null)
                      Expanded(
                        child: Text(
                          picked!.name,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                  ],
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Ï∑®ÏÜå'),
            ),
            ElevatedButton.icon(
              onPressed: save,
              icon: const Icon(Icons.save),
              label: const Text('Ï†ÄÏû•'),
            ),
          ],
        );
      }),
    );
  }

  Future<void> _createFlashcardSetFromSelection() async {
    if (_selectedIds.isEmpty) return;

    final titleCtl = TextEditingController();
    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('ÌîåÎûòÏãúÏπ¥Îìú ÏÑ∏Ìä∏ ÎßåÎì§Í∏∞'),
        content: TextField(
          controller: titleCtl,
          autofocus: true,
          decoration: const InputDecoration(
            labelText: 'ÏÑ∏Ìä∏ Ïù¥Î¶Ñ',
            hintText: 'Ïòà) Ïó¨Ìñâ ÌöåÌôî 1',
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Ï∑®ÏÜå')),
          ElevatedButton(onPressed: () => Navigator.pop(context, true), child: const Text('ÎßåÎì§Í∏∞')),
        ],
      ),
    );
    if (ok != true) return;

    try {
      await _ensureSignedIn();
      final uid = _uid!;
      final fs = FirebaseFirestore.instance;

      // 1) ÏÑ∏Ìä∏ Î¨∏ÏÑú Î®ºÏ†Ä ÏÉùÏÑ±(Í∑úÏπôÏóêÏÑú Ï∞∏Ï°∞ Í∞ÄÎä•ÌïòÎèÑÎ°ù)
      final setRef = fs.collection('flashcard_sets').doc();
      final title = titleCtl.text.trim().isEmpty ? 'ÏÉà ÏÑ∏Ìä∏' : titleCtl.text.trim();

      debugPrint('[CreateSet] writing set ${setRef.id}');
      await setRef.set({
        'uid'      : uid,
        'name'    : title,
        'createdAt': FieldValue.serverTimestamp(),
        'size'     : _selectedIds.length,
      });

      // 2) itemsÎäî Î≥ÑÎèÑ Î∞∞ÏπòÎ°ú ÏÉùÏÑ±
      WriteBatch batch = fs.batch();
      int order = 0;
      int ops = 0;

      for (final doc in _lastDocs) {
        if (!_selectedIds.contains(doc.id)) continue;

        final d = doc.data() as Map<String, dynamic>;
        final sentence = (d['sentence'] ?? '') as String;
        final meaning  = (d['meaning']  ?? '') as String;
        final imageUrl = (d['imageUrl'] ?? '') as String;

        final itemRef = setRef.collection('items').doc();
        batch.set(itemRef, {
          'addedAt': FieldValue.serverTimestamp(),
          'order'  : order, // top-levelÎèÑ Î≥¥Í¥Ä(Ìò∏ÌôòÏö©)
          'content': {
            'text'   : sentence,
            'meaning': meaning,
            'order'  : order,
            'type'   : 'custom',
            if (imageUrl.isNotEmpty) 'imageFrontUrl': imageUrl, // ÏïûÎ©¥ Ïù¥ÎØ∏ÏßÄ
            // Îí∑Î©¥ Ïù¥ÎØ∏ÏßÄÎäî Ï∂îÌõÑ Ìé∏Ïßë Ïãú 'imageBackUrl'Î°ú Ï∂îÍ∞Ä Í∞ÄÎä•
          },
          'sourceSentenceId': doc.id,
        });
        order++; ops++;

        // Î∞∞Ïπò ÌïúÎèÑ Î≥¥Ìò∏(Ïó¨Ïú†ÏûàÍ≤å Ï™ºÍ∞¨)
        if (ops == 450) {
          debugPrint('[CreateSet] committing partial batch...');
          await batch.commit();
          batch = fs.batch();
          ops = 0;
        }
      }

      if (ops > 0) {
        debugPrint('[CreateSet] committing final batch...');
        await batch.commit();
      }

      if (!mounted) return;
      setState(_selectedIds.clear);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('ÌîåÎûòÏãúÏπ¥Îìú ÏÑ∏Ìä∏Í∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.')),
      );

      // TODO: ÌïÑÏöîÌïòÎ©¥ Ïó¨Í∏∞ÏÑú ÌïôÏäµÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô
      // Navigator.push(context, MaterialPageRoute(builder: (_) => FlashcardStudyScreen(setId: setRef.id)));
    } on FirebaseException catch (e, st) {
      debugPrint('üî• set/items ÏÉùÏÑ± Ïã§Ìå®: ${e.code} ${e.message}\n$st');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('ÏÑ∏Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: ${e.code}')),
      );
    } catch (e, st) {
      debugPrint('üî• set/items ÏÉùÏÑ± Ïã§Ìå®(Í∏∞ÌÉÄ): $e\n$st');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('ÏÑ∏Ìä∏ ÏÉùÏÑ± Ïã§Ìå®(Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò)')),
      );
    }
  }

}

// ÌååÏùº Î∞îÍπ•(ÌïòÎã®)Ïóê Îë°ÎãàÎã§.
class _EmptyHint extends StatelessWidget {
  const _EmptyHint();

  @override
  Widget build(BuildContext context) {
    return ListView(
      children: const [
        SizedBox(height: 120),
        Center(
          child: Text(
            'Ï†ÄÏû•Îêú Î¨∏Ïû•Ïù¥ ÏóÜÏñ¥Ïöî.\nÏò§Î•∏Ï™Ω ÏÉÅÎã® + Î≤ÑÌäºÏúºÎ°ú Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.',
            textAlign: TextAlign.center,
          ),
        ),
      ],
    );
  }
}
